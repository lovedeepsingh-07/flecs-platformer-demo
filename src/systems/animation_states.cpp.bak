#include "components.hpp"
#include "systems.hpp"

void AnimationStatesSystem::update(GameContext::GameContext& ctx) {
    flecs::system texture_flipping_sys =
        ctx.registry
            .system<components::TextureComponent, components::MovementComponent>()
            .each([](components::TextureComponent& texture,
                     const components::MovementComponent& movement) {
                if (movement.left) {
                    texture.flipped = true;
                }
                if (movement.right) {
                    texture.flipped = false;
                }
            });
    texture_flipping_sys.run();

    flecs::query<> animation_states_query =
        ctx.registry.query_builder()
            .with<components::MovementComponent>()
            .with<components::AttackComponent>()
            .with<components::AnimationComponent>()
            .with<components::AnimationStatesComponent>()
            .build();

    ctx.registry.defer_begin();
    animation_states_query.run([](flecs::iter& iter) {
        while (iter.next()) {
            auto movement = iter.field<components::MovementComponent>(0);
            auto attack = iter.field<components::AttackComponent>(1);
            auto animation = iter.field<components::AnimationComponent>(2);
            for (auto i : iter) {
                flecs::entity curr_entity = iter.entity(i);
                std::string new_state;
                if (attack[i].attacking) {
                    if (!movement[i].on_ground) {
                        new_state = "attack_air";
                    } else {
                        new_state = "attack_3";
                    }
                } else {
                    if (!movement[i].on_ground) {
                        new_state = "jump";
                    } else if (movement[i].left || movement[i].right) {
                        new_state = "run";
                    } else {
                        new_state = "idle";
                    }
                }
                if (animation[i].curr_state != new_state) {
                    animation[i].curr_state = new_state;
                    animation[i].curr_frame_index = 0;
                    animation[i].time_accumulator = 0.0F;
                    animation[i].playing = true;
                    animation[i].finished = false;
                }

                if (attack[i].attacking && animation[i].finished
                    && curr_entity.has<components::AttackEventComponent>()) {
                    attack[i].attacking = false;
                    curr_entity.remove<components::AttackEventComponent>();
                }
            }
        }
    });
    ctx.registry.defer_end();
}
